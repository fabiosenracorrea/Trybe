# 37.3 - SORT & SEARCH ALGORITHMS

Two of the most important things almost EVERY program does are sorting and searching for items in collections. May it be a simple ten-item grocery list or [Discord's 100000+ user server](https://blog.discord.com/using-rust-to-scale-elixir-for-11-million-concurrent-users-c6f19fc029d3).

For that, you have to make it **FAST**. REALLY!

These are one of those cases you can do it a million ways. If the performance is lacking, you can throw it away.

## SORTING ALGORITHMS

### BRUTE FORCE

Pretty standard. Try every combination you have, one is correct. Eg: Find the combination of a 4-digit [0-9] lock. No clues, no nothing. THe only way around it is to try from 0000 to 9999 until it cracks open.

### SELECTION SORT

[A nice explanation](https://www.geeksforgeeks.org/selection-sort/)

### INSERTION SORT

[A nice explanation](https://www.geeksforgeeks.org/insertion-sort/)

### BUBBLE SORT

[A nice explanation](https://www.geeksforgeeks.org/bubble-sort/)

### QUICK SORT

[A nice explanation](https://www.geeksforgeeks.org/quick-sort/)

### MERGE SORT

Hey! *Recursive* warning. And performance :)

[A nice explanation](https://www.geeksforgeeks.org/merge-sort/)

## SEARCH ALGORITHMS

### LINEAR SEARCH

[A nice explanation](https://www.geeksforgeeks.org/linear-search/)

### BINARY SEARCH

This one is great! But comes with a initial cost of *sorting* the list first.

[A nice explanation](https://www.geeksforgeeks.org/binary-search/)

## Exercises

On this module we don't have any exercise, as it's more of a conceptual lesson. You can, however, try these algorithms on your favorite language. Even better, time them out to see the Big O differences in action!

----

###### Feedback

As always, any feedback or suggestion is welcomed.

